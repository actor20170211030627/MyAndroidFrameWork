package com.actor.myandroidframework.application;import android.app.Application;import android.content.Context;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.actor.myandroidframework.utils.ConfigUtils;import com.blankj.utilcode.util.CrashUtils;import com.blankj.utilcode.util.Utils;import okhttp3.OkHttpClient;/** * Description: 自定义的Application 继承本类, 然后在清单文件中注册 *              https://gitee.com/actor20170211030627/MyAndroidFrameWork * Author     : ldf * Date       : 2019/7/21 on 16:59 */public abstract class ActorApplication extends Application/*MultiDexApplication implements Thread.UncaughtExceptionHandler*/ {    /**     * 在 onCreate 之前调用, 可以做一些较早的初始化     * 常用于 MultiDex 以及插件化框架的初始化     */    @Override    protected void attachBaseContext(Context base) {        super.attachBaseContext(base);//        MultiDex.install(this);    }    /**     * 在模拟环境中程序终止时会被调用     */    @Override    public void onTerminate() {        super.onTerminate();    }    @Override    public void onCreate() {        super.onCreate();        initAllKits();    }    /**     * 初始化项目所需的资源, 可重写此方法, 自定义配置     */    protected void initAllKits() {        //配置工具类        Utils.init(this);        ConfigUtils.initAllKits(this);        //默认配置OkHttp        OkHttpClient.Builder builder = ConfigUtils.initOkHttp(isAppDebug());        //用户自定义配置        OkHttpClient.Builder builder2 = configOkHttpClientBuilder(builder);        if (builder2 != null) builder = builder2;        //OkHttp配置完后, 再增加1个日志拦截器, 用于打印非常标准的请求日志        ConfigUtils.okHttpAddLogInterceptor(builder, isAppDebug());        //初始化崩溃处理        ConfigUtils.initDefaultUncaughtExceptionHandler(isAppDebug(), new CrashUtils.OnCrashListener() {            @Override            public void onCrash(CrashUtils.CrashInfo crashInfo) {                onUncaughtException(crashInfo.getThrowable());            }        });    }    /**     * 配置Builder, 主要是配置'超时' & '重试' & '拦截器' 等, 示例:     * builder.connectTimeout(30_000L, TimeUnit.MILLISECONDS)//默认10s, 可不设置     *          .readTimeout(30_000L, TimeUnit.MILLISECONDS) //默认10s, 可不设置     *          .writeTimeout(30_000L, TimeUnit.MILLISECONDS)//默认10s, 可不设置     *          .addInterceptor(new AddHeaderInterceptor())  //网络请求前添加请求头, 如果不添加可不设置     *          .addInterceptor(new My401Error$RefreshTokenInterceptor(this));//在某个项目中,401表示token过期,需要刷新token并重新请求, 根据自己项目而定     * @return 返回builder, 可以返回null     */    @Nullable    protected abstract OkHttpClient.Builder configOkHttpClientBuilder(@NonNull OkHttpClient.Builder builder);    /**     * release环境中App崩溃的时候会回调这个方法.     * 如果是debug环境, 不会抓取bug并且不会回调这个方法     * @param e 堆栈信息     *     * 示例处理:     * Intent intent = new Intent(this, LoginActivity.class);     * intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);     * PendingIntent restartIntent = PendingIntent.getActivity(this, 0, intent, 0);     * //定时器     * AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);     * mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, restartIntent);//1000:1秒钟后重启应用     * System.exit(-1);//退出     * //android.os.Process.killProcess(android.os.Process.myPid());//也一样是退出     */    protected void onUncaughtException(Throwable e) {        System.exit(-1);    //退出    }    /**     * 如果release版本也想输出日志，那么这个时候我们到 AndroidManifest.xml 中设置debuggable="true"即可.     * 或者重写此方法自定义返回.     */    protected boolean isAppDebug() {        return ConfigUtils.IS_APP_DEBUG;    }}